msgid ""
msgstr ""
"Project-Id-Version: idforge-modules.5\n"
"POT-Creation-Date: 2015-03-08 15:22-0400\n"
"PO-Revision-Date: 2015-03-08 15:22-0400\n"
"Last-Translator: The CentOS Documentation SIG <centos-docs@centos.org>\n"
"Language-Team: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "idforge-modules"
msgstr ""

msgid "5"
msgstr ""

msgid "Describes idforge module environments."
msgstr ""

msgid "idforge(1)"
msgstr ""

msgid ""
"The module environment of <placeholder-1/> is a collection of Bash "
"functions grouped by meaning and executed based on specific "
"conditions only. Each module environment can be nested inside "
"another to create a chain of individual execution environments with "
"their own scopes. The higher module environment is visible to all "
"its subsequent module environments, but not the opposite."
msgstr ""

msgid "usage"
msgstr ""

msgid "version"
msgstr ""

msgid ""
"The modular design of <placeholder-1/> allows you to optimize the "
"construction of your shell scripts based on the features you want "
"to implement. For example, consider the case of printing both "
"command’s usage and version information. The output of these "
"actions is conceptually different, so each one has its own module "
"inside <placeholder-2/> (e.g., <placeholder-3/> and <placeholder-4/"
">, respectively). When you request usage information only the "
"functions related to usage information are loaded. No function "
"related to version information is loaded in such case."
msgstr ""

msgid "tcar"
msgstr ""

msgid "idforge"
msgstr ""

msgid ""
"The modular design of <placeholder-1/> was introduced in tcar-0.5, "
"making it possible to divide long tasks into smaller tasks easier "
"to debug, maintain and share with other modules efficiently. After "
"version 0.12, the <placeholder-2/> package was renamed to "
"<placeholder-3/>, and its version number reset to 0.1."
msgstr ""

msgid "Module Environment"
msgstr ""

msgid ""
"When you execute <placeholder-1/> it creates a shell environment in "
"which variables and functions can be defined. This environment has "
"the highest scope and contains variables and functions that will "
"always be available in subsequent module environments."
msgstr ""

msgid "Execution environment of hello module"
msgstr ""

msgid ""
"idforge.sh <co id=\"CO1-1\"/> `-- idforge() <co id=\"CO1-2\"/> `-- "
"idforge_setModuleEnvironment() <co id=\"CO1-3\"/> `-- hello() <co "
"id=\"CO1-4\"/>"
msgstr ""

msgid "Script initialization"
msgstr ""

msgid "Library initialization"
msgstr ""

msgid "Module initialization"
msgstr ""

msgid "Module environment"
msgstr ""

msgid ""
"A module environment is a collection of functions that perform "
"small tasks and can be further executed in a specific order to "
"produce specific results. They are executed and destroyed at demand "
"based on their hierarchy (e.g., whether they are \"parent modules"
"\", \"child modules\", or \"sibling modules\")."
msgstr ""

msgid ""
"<xref linkend=\"module-environments-in-action\"/> shows how module "
"environments are created and destroyed after executing the the "
"following command:"
msgstr ""

msgid "]$ idforge hello --camel hello"
msgstr ""

msgid "Module environments in action"
msgstr ""

msgid "..."
msgstr ""

msgid "Parent Modules"
msgstr ""

msgid ""
"A new parent module environment is initiated when you call the "
"following function:"
msgstr ""

msgid "idforge_setModuleEnvironment -t \"parent\" -m \"modulename\""
msgstr ""

msgid "--debug"
msgstr ""

msgid "parent"
msgstr ""

msgid ""
"When the <placeholder-1/> option is provided in the <placeholder-2/"
"> command-line, the sibling modules are identified by the word "
"<placeholder-3/> on the right side of IDFORGE_MODULE_TYPE "
"environment variable."
msgstr ""

msgid ""
"Parent modules are very simple in design and you can use them to "
"implement simple solutions quickly. Normally, when you execute a "
"parent module, you initiate the highest module environment possible "
"inside <placeholder-1/> execution environment. Parent modules are "
"frequently used to define module-specifc global variables, "
"interpret module-specific options passed through the command-line "
"and execute the appropriate actions based on them (e.g., executing "
"a chain of child modules)."
msgstr ""

msgid "idforge-hello parent module directory layout"
msgstr ""

msgid "Module initialization."
msgstr ""

msgid "Module command-line parser."
msgstr ""

msgid "Module description."
msgstr ""

msgid "function"
msgstr ""

msgid "{"
msgstr ""

msgid ".sh"
msgstr ""

msgid ""
"The module’s initialization contains the module’s main function "
"definition. The function definition is written using the long "
"definition format (i.e., it must begin with the word <placeholder-1/"
">, then the function name, and finally the <placeholder-2/> "
"character). The name of the function is exactly the same of the "
"initialization file but without the <placeholder-3/> extension. "
"These conditions are required in order for <placeholder-4/> script "
"to execute the function definition and destroy it when it is no "
"longer used. See <xref linkend=\"hello\"/>."
msgstr ""

msgid ""
"Inside the function definition you write all the commands you want "
"the module to run, once executed. The function definition can be as "
"simple as one single line of code or as complex as you can imagine "
"(too complex code is sign of bad design, so keep it simple). It is "
"the place where you express your solutions."
msgstr ""

msgid ""
"In case you notice the initialization file is growing up "
"inevitably, you can reduce its code by refactoring it. To do so, "
"you can use resources like module-specific functions and child "
"modules. These resources are described in <xref linkend=\"module-"
"optimization\"/>, and they help you to keep the initialization file "
"in a simple state, easy to understand, maintain and debug."
msgstr ""

msgid "hello.sh"
msgstr ""

msgid ""
"When you write functions for <placeholder-1/> modules you must add "
"a top comment describing the legal status of the source code of "
"such function you write. The source code of <placeholder-2/> is "
"distributed under the terms of GNU Public License (GPL) version 2. "
"This repetitive legal information needs to be present in all "
"function scripts that make <placeholder-3/> to avoid unexpected "
"misunderstanding about the legal status of the source code, so as "
"to protect the overall operation of it (see the section \"How to "
"Apply These Terms to Your New Programs\" in the LICENSE file)."
msgstr ""

msgid "Module Optimization"
msgstr ""

msgid "related functions"
msgstr ""

msgid "child modules"
msgstr ""

msgid "sibling modules"
msgstr ""

msgid "recursive modules"
msgstr ""

msgid ""
"The module environment the <placeholder-1/> command provides has "
"four resources that you can use to optimize your module "
"implementations. These resources are <placeholder-2/>, <placeholder-"
"3/>, <placeholder-4/> and <placeholder-5/>."
msgstr ""

msgid "Related Functions"
msgstr ""

msgid ""
"Related functions or module-specific functions are very useful when "
"you need to refactor a module implementation. Related functions "
"must be created thinking in executing them always, whenever the "
"module scope they pertain to is executed. Such an example of this "
"usage is how parent modules parse arguments provided in the command-"
"line. For example, the initialization script <xref linkend=\"hello"
"\"/> uses the <xref linkend=\"hello_setOptions\"/> related function "
"to interpret the arguments passed through the command-line. Notice "
"how many lines in the initialization script has been reduced."
msgstr ""

msgid "\\_"
msgstr ""

msgid "hello_setOptions.sh"
msgstr ""

msgid "hello_setOptions"
msgstr ""

msgid ""
"Related functions are written using the module’s name, then an "
"underscore (<placeholder-1/>), then a descriptive name and, "
"finally, the <placeholder-2/> extension. The function definition "
"inside the function file also follows such convention but excludes "
"the <placeholder-3/> extension from name (e.g., the function file "
"<placeholder-4/> has a function definition named <placeholder-5/> "
"inside). These conventions are used to export and destroy the "
"related functions when new module environments are created and "
"destroyed. If you create related function files with a pattern "
"different from that described here, they will not be executed nor "
"available inside the initialization file of the module environment "
"being currently executed."
msgstr ""

msgid "hello_setOptions.sh (legal status cut for brevity)"
msgstr ""

msgid "--help"
msgstr ""

msgid "--version"
msgstr ""

msgid "--description"
msgstr ""

msgid ""
"The related function <xref linkend=\"hello_setOptions\"/> presents "
"the construction standard we use inside <placeholder-1/> for "
"parsing arguments passed through the command-line in a per-module "
"basis. As convention, all the parent modules definitions you write "
"must be able to interpret the <placeholder-2/>, <placeholder-3/> "
"and <placeholder-4/> options using the construction described here."
msgstr ""

msgid ""
"Related functions aren’t very efficient when you need to execute "
"them based on specific conditions. When a module is executed, "
"related functions are exported to <placeholder-1/> shell "
"environment. They remain there, consuming memory, until the module "
"they belong to is destroyed. If you create a related function and "
"never execute it, it will consume memory, as well, and will end up "
"being a waste of resources. So, use related functions when you are "
"absolutely sure they will be executed at some point, in one single "
"iteration of <placeholder-2/>. If you need to execute functions "
"based on specific conditions, use child modules, instead."
msgstr ""

msgid "Child Modules"
msgstr ""

msgid ""
"A new child module environment is initiated when you call the "
"following function:"
msgstr ""

msgid "idforge_setModuleEnvironment -t \"child\" -m \"modulename\""
msgstr ""

msgid "child"
msgstr ""

msgid ""
"The child modules have the characteristic of being nested modules. "
"They cannot be executed directly from the command-line. Normally, "
"child modules are executed from one parent modules but they can be "
"executed from other child modules, as well."
msgstr ""

msgid ""
"When several child modules are executed in one single iteration of "
"<placeholder-1/>, they create a chain of modules. Chain of modules "
"are generally created when you want to divide one large task into "
"smaller tasks and also control which of these smaller tasks is "
"executed based on specific conditions (e.g., you may want to render "
"images or documentation, but not both, in one single iteration of "
"<placeholder-2/> script)."
msgstr ""

msgid ""
"In a chain of modules, lower modules in the chain (those started "
"last) have access to information set by modules higher in the chain "
"(those started first), but not in the opposite order. When "
"processing information this way, modules aren’t destroyed until the "
"last module executed in the chain has finished its work (e.g., all "
"the commands inside it have been executed). At that point, child "
"modules are destroyed automatically in the reverse order they were "
"executed."
msgstr ""

msgid "lower"
msgstr ""

msgid "upper"
msgstr ""

msgid "camel"
msgstr ""

msgid ""
"<xref linkend=\"module-environments-in-action\"/> shows the child "
"modules' ability of reducing scope as they get deeper in the chain "
"of executed modules. However, child modules lack the possibility of "
"nesting modules that share the same scope. For instance, <xref "
"linkend=\"module-environments-in-action\"/>, you cannot execute the "
"modules <placeholder-1/> or <placeholder-2/> from <placeholder-3/> "
"module, as if they were child modules of <placeholder-4/> module. "
"That is not possible because they all have the same scope, which "
"is, to print the greeting message to standard output."
msgstr ""

msgid ""
"The child modules are an effective way of expanding the scope of "
"the chain of module environment based on specific condition. "
"However, when module environments share the same level of hierarchy "
"in the directory structure they cannot be called as child one from "
"another. In such cases, you need to use <placeholder-1/>, instead."
msgstr ""

msgid "Sibling Modules"
msgstr ""

msgid ""
"A new sibling module environment is initiated when you call the "
"following function:"
msgstr ""

msgid "idforge_setModuleEnvironment -t \"sibling\" -m \"modulename\""
msgstr ""

msgid "sibling"
msgstr ""

msgid ""
"The sibling modules are another type of nested modules but, in "
"contrast to child modules, sibling modules cannot be executed from "
"parent modules. Normally, sibling modules are executed from other "
"sibling modules but, considering the context, they can be executed "
"from child modules too, to initiate sibling processing."
msgstr ""

msgid ""
"When several siblings modules are executed, they also build a chain "
"of modules. In contrast to chain of child modules, the chain of "
"sibling modules destroys the last sibling module executed before "
"executing the next sibling module. This makes the chain to stop its "
"growing at sibling module processing, unless you call a child "
"module from a sibling module. In which case, the chain expansion "
"would continue growing as long as the number of child modules you "
"execute. This process becomes more visible when you take a look at "
"<xref linkend=\"module-environments-in-action\"/>."
msgstr ""

msgid ""
"Normally, one module is executed at some point and destroyed at the "
"same point when it has finished its work, however, what if the next "
"immediate module you are about to execute is the same module you "
"are about to destroy? This is, you need to execute the last module "
"in the chain of executed modules again, but, this time, from "
"itself. In cases like this, the <placeholder-1/> script doesn’t "
"destroy the last module. It cannot, because you are certainly "
"executing a new module from itself, so it has to wait for this new "
"call to finish in order to be destroyed. This kind of processing is "
"known as \"processing sibling modules recursively.\""
msgstr ""

msgid "Recursive Modules"
msgstr ""

msgid ""
"When one module environment executes as sibling of itself we are in "
"presence of a recursive sibling module execution. The recursive "
"execution of sibling modules doesn’t destroy the last module in the "
"chain of executed modules and doesn’t increment or decrement the "
"module counter either. The module counter is somehow frozen until a "
"different module environment is executed. In cases like this, the "
"last module environment remains in memory for the new module "
"execution so it can be reused. This process becomes more visible "
"when you take a look at <xref linkend=\"debug-recursive-modules\"/>."
msgstr ""

msgid ""
"When you execute sibling modules recursively, you must be very "
"careful not to get trapped into an endless loop."
msgstr ""

msgid "Processing execution of modules recursively"
msgstr ""

msgid "→"
msgstr ""

msgid "~&gt;"
msgstr ""

msgid "random"
msgstr ""

msgid ""
"Recursive execution of modules occurs only when the module you are "
"executing is considered sibling of the last module executed in the "
"chain of executed modules and they both have the same name. The "
"fact that no variable name is printed out in <xref linkend=\"debug-"
"recursive-modules\"/> means that they were not created. The arrows' "
"style changes from <placeholder-1/> to <placeholder-2/> meaning "
"that module-specific functions weren’t exported for the new module "
"execution either. It also means that the initialization script is "
"reusing both related functions and variables from the last module "
"environment in the chain of executed modules. In this case the "
"<placeholder-3/> module."
msgstr ""

msgid "Files"
msgstr ""

msgid "Library/"
msgstr ""

msgid "…"
msgstr ""

msgid "Library/Modules/Name/&lt;name&gt;.sh"
msgstr ""

msgid "Sell scripts for module initialization"
msgstr ""

msgid "Library/Modules/Name/&lt;name&gt;_setOptions.sh"
msgstr ""

msgid "Shell script used to define the module’s command-line."
msgstr ""

msgid "Library/Modules/Name/Modules/"
msgstr ""

msgid ""
"This directory contains nested modules (e.g., child modules) and is "
"used for extending the current module functionality in a modular "
"way. There isn’t a visible limitation in the number of Modules "
"directories you can nest inside one module to achieve certain "
"functionality so, you can create as many levels of Modules "
"directories as you need."
msgstr ""

msgid "Locales/"
msgstr ""

msgid "idforge-locale(1)"
msgstr ""

msgid ""
"This directory contains shell scripts' localization files in PO "
"format. The content of this directory is managed using the "
"<placeholder-1/> command with the \"Locales/idforge.conf\" "
"configuration file as argument."
msgstr ""

msgid "Manuals/"
msgstr ""

msgid "idforge-render(1)"
msgstr ""

msgid ""
"This directory contains shell scripts' documentation manuals in "
"asciidoc format as well as a Locales/ sub-directory to manage "
"localization of documentation manuals. Documentation manuals are "
"organized one per command (e.g., <placeholder-1/> documentation is "
"in idforge.1.asciidoc, <placeholder-2/> documentation would be "
"idforge-render.1.asciidoc, and so on for each command). The "
"localization of documentation manuals in this directory are manged "
"by <placeholder-3/> command and the Manuals/idforge.conf "
"configuration file."
msgstr ""

msgid "Author"
msgstr "Autor"

msgid "alain.reguera@gmail.com"
msgstr ""

msgid "Written by Alain Reguera Delgado &lt;<placeholder-1/>&gt;"
msgstr "Escrito por Alain Reguera Delgado &lt;<placeholder-1/>&gt;"

msgid "Reporting Bugs"
msgstr "Reportando Errores"

msgid "centos-devel@centos.org"
msgstr ""

msgid "Report bugs to CentOS developers mailing list &lt;<placeholder-1/>&gt;"
msgstr ""
"Reporte los problemas a la lista de correo de los desarrolladores de CentOS "
"&lt;<placeholder-1/>&gt;"

msgid "Copyright"
msgstr "Restricciones para la distribución de copias"

msgid "Copyright © =MANPAGE_YEAR= The CentOS Artwork SIG"
msgstr ""

msgid ""
"idFORGE Framework is free software; you can redistribute it and/or modify it "
"under the terms of the GNU General Public License as published by the Free "
"Software Foundation; either version 2 of the License, or (at your option) "
"any later version."
msgstr ""
"idFORGE Framework es software libre; usted puede redistribuirlo y/o "
"modificarlo bajo los términos de la Licencia Pública General de GNU como se "
"publicó por la Free Software Foundation; ya sea en la versión 2 de la "
"Licencia, o (a su opinión) cualquier versión posterior."

msgid ""
"idFORGE Framework is distributed in the hope that it will be useful, but "
"WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY "
"or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for "
"more details."
msgstr ""
"idFORGE Framework es distribuido en la expectativa de que será util, pero "
"SIN NINGUNA GARANTÍA; incluso sin la garantía implicita de COMERCIALIZACIÓN "
"o IDIONIDAD PARA UN PROPÓSIGO PARTICULAR. Vease la Licencia General Pública "
"de GNU para los detalles."

msgid ""
"You should have received a copy of the GNU General Public License along with "
"idFORGE Framework; if not, write to the Free Software Foundation, Inc., 675 "
"Mass Ave, Cambridge, MA 02139, USA."
msgstr ""
"Usted debe haber recibido una copia de la Licencia General Pública de GNU "
"junto a idFORGE Framework; de lo contrario, escriba a la Free Software "
"Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA."

msgid "See Also"
msgstr "Vea Además"

msgid "=MANPAGE_OTHERS="
msgstr ""
