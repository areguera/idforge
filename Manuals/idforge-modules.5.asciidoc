= idforge-modules(5)
Alain Reguera Delgado <alain.reguera@gmail.com>
0.2, 2015:

== Name

idforge-modules - Describes idforge module environments.

== Synopsis

The module environment of *idforge* is a collection of Bash functions
grouped by meaning and executed based on specific conditions only.
Each module environment can be nested inside another to create a chain
of individual execution environments with their own scopes. The higher
module environment is visible to all its subsequent module
environments, but not the opposite.

The modular design of *idforge* allows you to optimize the
construction of your shell scripts based on the features you want to
implement. For example, consider the case of printing both command's
usage and version information. The output of these actions is
conceptually different, so each one has its own module inside
*idforge* (e.g., usage and version, respectively). When you request
usage information only the functions related to usage information are
loaded. No function related to version information is loaded in such
case.

The modular design of *idforge* was introduced in tcar-0.5, making it
possible to divide long tasks into smaller tasks easier to debug,
maintain and share with other modules efficiently.

[[module-environment]]
== Module Environment

When you execute *idforge* it creates a shell environment in which
variables and functions can be defined. This environment has the
highest scope and contains variables and functions that will always be
available in subsequent module environments.

.Execution environment of hello module
======================================================================
----------------------------------------------------------------------
idforge                                 Script initialization
`-- idforge()                           Library initialization
    `-- idforge_setModuleEnvironment()  Module initialization
        `-- hello()                     Module environment
----------------------------------------------------------------------
======================================================================

A module environment is a collection of functions that perform small
tasks and can be further executed in a specific order to produce
specific results.  They are executed and destroyed at demand based on
their hierarchy (e.g., whether they are "parent modules", "child
modules", or "sibling modules").

<<module-environments-in-action>> shows how module environments are
created and destroyed after executing the _idforge hello --camel hello_
command.

[[module-environments-in-action]]
.Module environments in action
======================================================================
----------------------------------------------------------------------
09:57:59 =========================>  	[0] | main
09:57:59 SCRIPT_MODULE_BASEDIR       	/usr/libexec/idforge/Modules
09:57:59 SCRIPT_MODULE_NAME          	[0]=hello
09:57:59 SCRIPT_MODULE_TYPE          	parent
09:57:59 SCRIPT_MODULE_ARGUMENT      	--camel hello 
09:57:59 SCRIPT_MODULE_LIST          	hello|locale|pack|prepare|render|tuneup
09:57:59 SCRIPT_MODULE_DIR           	/usr/libexec/idforge/Modules/Hello
09:57:59 SCRIPT_MODULE_DIR_MODULES   	/usr/libexec/idforge/Modules/Hello/Modules
09:57:59 SCRIPT_MODULE_DIR_CONFIGS   	/usr/libexec/idforge/Modules/Hello/Configs
09:57:59 SCRIPT_MODULE_DIR_MANUALS   	/usr/libexec/idforge/Modules/Hello/Manuals
09:57:59 SCRIPT_MODULE_DIR_LOCALES   	/usr/share/locale/
09:57:59 SCRIPT_MODULE_INIT_FILE     	/usr/libexec/idforge/Modules/Hello/hello.sh
09:57:59 TEXTDOMAIN                  	idforge
09:57:59 TEXTDOMAINDIR               	/usr/share/locale/
09:57:59 export -f                   	hello
09:57:59 export -f                   	hello_getOptions
09:57:59 export -f                   	hello_printDescription
09:57:59 ------------------------->  	hello --camel hello 
09:57:59 =========================>  	[1] | hello
09:57:59 SCRIPT_MODULE_BASEDIR       	/usr/libexec/idforge/Modules/Hello/Modules
09:57:59 SCRIPT_MODULE_NAME          	[1]=output
09:57:59 SCRIPT_MODULE_TYPE          	child
09:57:59 SCRIPT_MODULE_ARGUMENT      	
09:57:59 SCRIPT_MODULE_LIST          	output
09:57:59 SCRIPT_MODULE_DIR           	/usr/libexec/idforge/Modules/Hello/Modules/Output
09:57:59 SCRIPT_MODULE_DIR_MODULES   	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules
09:57:59 SCRIPT_MODULE_DIR_CONFIGS   	/usr/libexec/idforge/Modules/Hello/Modules/Output/Configs
09:57:59 SCRIPT_MODULE_DIR_MANUALS   	/usr/libexec/idforge/Modules/Hello/Manuals
09:57:59 SCRIPT_MODULE_DIR_LOCALES   	/usr/share/locale/
09:57:59 SCRIPT_MODULE_INIT_FILE     	/usr/libexec/idforge/Modules/Hello/Modules/Output/output.sh
09:57:59 TEXTDOMAIN                  	idforge
09:58:00 TEXTDOMAINDIR               	/usr/share/locale/
09:58:00 export -f                   	output
09:58:00 ------------------------->  	output 
09:58:00 =========================>  	[2] | output
09:58:00 SCRIPT_MODULE_BASEDIR       	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules
09:58:00 SCRIPT_MODULE_NAME          	[2]=camel
09:58:00 SCRIPT_MODULE_TYPE          	child
09:58:00 SCRIPT_MODULE_ARGUMENT      	
09:58:00 SCRIPT_MODULE_LIST          	camel|lower|random|upper
09:58:00 SCRIPT_MODULE_DIR           	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Camel
09:58:00 SCRIPT_MODULE_DIR_MODULES   	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Camel/Modules
09:58:00 SCRIPT_MODULE_DIR_CONFIGS   	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Camel/Configs
09:58:00 SCRIPT_MODULE_DIR_MANUALS   	/usr/libexec/idforge/Modules/Hello/Manuals
09:58:00 SCRIPT_MODULE_DIR_LOCALES   	/usr/share/locale/
09:58:00 SCRIPT_MODULE_INIT_FILE     	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Camel/camel.sh
09:58:00 TEXTDOMAIN                  	idforge
09:58:00 TEXTDOMAINDIR               	/usr/share/locale/
09:58:00 export -f                   	camel
09:58:00 ------------------------->  	camel 
09:58:00 =========================>  	[3] | camel
09:58:00 SCRIPT_MODULE_BASEDIR       	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules
09:58:00 SCRIPT_MODULE_NAME          	[3]=upper
09:58:00 SCRIPT_MODULE_TYPE          	sibling
09:58:00 SCRIPT_MODULE_ARGUMENT      	
09:58:00 SCRIPT_MODULE_LIST          	camel|lower|random|upper
09:58:00 SCRIPT_MODULE_DIR           	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Upper
09:58:00 SCRIPT_MODULE_DIR_MODULES   	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Upper/Modules
09:58:00 SCRIPT_MODULE_DIR_CONFIGS   	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Upper/Configs
09:58:00 SCRIPT_MODULE_DIR_MANUALS   	/usr/libexec/idforge/Modules/Hello/Manuals
09:58:00 SCRIPT_MODULE_DIR_LOCALES   	/usr/share/locale/
09:58:00 SCRIPT_MODULE_INIT_FILE     	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Upper/upper.sh
09:58:00 TEXTDOMAIN                  	idforge
09:58:00 TEXTDOMAINDIR               	/usr/share/locale/
09:58:00 export -f                   	upper
09:58:00 ------------------------->  	upper 
H              	
09:58:00 <-------------------------  	upper 
09:58:00 unset -f                    	upper
09:58:00 <=========================  	[3] | camel
09:58:00 =========================>  	[3] | camel
09:58:00 SCRIPT_MODULE_BASEDIR       	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules
09:58:00 SCRIPT_MODULE_NAME          	[3]=lower
09:58:00 SCRIPT_MODULE_TYPE          	sibling
09:58:00 SCRIPT_MODULE_ARGUMENT      	
09:58:00 SCRIPT_MODULE_LIST          	camel|lower|random|upper
09:58:00 SCRIPT_MODULE_DIR           	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Lower
09:58:00 SCRIPT_MODULE_DIR_MODULES   	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Lower/Modules
09:58:00 SCRIPT_MODULE_DIR_CONFIGS   	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Lower/Configs
09:58:00 SCRIPT_MODULE_DIR_MANUALS   	/usr/libexec/idforge/Modules/Hello/Manuals
09:58:00 SCRIPT_MODULE_DIR_LOCALES   	/usr/share/locale/
09:58:00 SCRIPT_MODULE_INIT_FILE     	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Lower/lower.sh
09:58:00 TEXTDOMAIN                  	idforge
09:58:00 TEXTDOMAINDIR               	/usr/share/locale/
09:58:00 export -f                   	lower
09:58:00 ------------------------->  	lower 
e              	
09:58:00 <-------------------------  	lower 
09:58:00 unset -f                    	lower
09:58:00 <=========================  	[3] | camel
09:58:00 =========================>  	[3] | camel
09:58:00 SCRIPT_MODULE_BASEDIR       	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules
09:58:00 SCRIPT_MODULE_NAME          	[3]=upper
09:58:00 SCRIPT_MODULE_TYPE          	sibling
09:58:00 SCRIPT_MODULE_ARGUMENT      	
09:58:00 SCRIPT_MODULE_LIST          	camel|lower|random|upper
09:58:00 SCRIPT_MODULE_DIR           	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Upper
09:58:00 SCRIPT_MODULE_DIR_MODULES   	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Upper/Modules
09:58:00 SCRIPT_MODULE_DIR_CONFIGS   	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Upper/Configs
09:58:00 SCRIPT_MODULE_DIR_MANUALS   	/usr/libexec/idforge/Modules/Hello/Manuals
09:58:00 SCRIPT_MODULE_DIR_LOCALES   	/usr/share/locale/
09:58:00 SCRIPT_MODULE_INIT_FILE     	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Upper/upper.sh
09:58:00 TEXTDOMAIN                  	idforge
09:58:00 TEXTDOMAINDIR               	/usr/share/locale/
09:58:00 export -f                   	upper
09:58:00 ------------------------->  	upper 
L              	
09:58:00 <-------------------------  	upper 
09:58:00 unset -f                    	upper
09:58:00 <=========================  	[3] | camel
09:58:00 =========================>  	[3] | camel
09:58:00 SCRIPT_MODULE_BASEDIR       	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules
09:58:00 SCRIPT_MODULE_NAME          	[3]=lower
09:58:00 SCRIPT_MODULE_TYPE          	sibling
09:58:00 SCRIPT_MODULE_ARGUMENT      	
09:58:00 SCRIPT_MODULE_LIST          	camel|lower|random|upper
09:58:00 SCRIPT_MODULE_DIR           	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Lower
09:58:00 SCRIPT_MODULE_DIR_MODULES   	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Lower/Modules
09:58:00 SCRIPT_MODULE_DIR_CONFIGS   	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Lower/Configs
09:58:00 SCRIPT_MODULE_DIR_MANUALS   	/usr/libexec/idforge/Modules/Hello/Manuals
09:58:00 SCRIPT_MODULE_DIR_LOCALES   	/usr/share/locale/
09:58:00 SCRIPT_MODULE_INIT_FILE     	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Lower/lower.sh
09:58:00 TEXTDOMAIN                  	idforge
09:58:00 TEXTDOMAINDIR               	/usr/share/locale/
09:58:00 export -f                   	lower
09:58:00 ------------------------->  	lower 
l              	
09:58:00 <-------------------------  	lower 
09:58:00 unset -f                    	lower
09:58:00 <=========================  	[3] | camel
09:58:00 =========================>  	[3] | camel
09:58:00 SCRIPT_MODULE_BASEDIR       	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules
09:58:00 SCRIPT_MODULE_NAME          	[3]=upper
09:58:00 SCRIPT_MODULE_TYPE          	sibling
09:58:00 SCRIPT_MODULE_ARGUMENT      	
09:58:00 SCRIPT_MODULE_LIST          	camel|lower|random|upper
09:58:00 SCRIPT_MODULE_DIR           	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Upper
09:58:00 SCRIPT_MODULE_DIR_MODULES   	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Upper/Modules
09:58:01 SCRIPT_MODULE_DIR_CONFIGS   	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Upper/Configs
09:58:01 SCRIPT_MODULE_DIR_MANUALS   	/usr/libexec/idforge/Modules/Hello/Manuals
09:58:01 SCRIPT_MODULE_DIR_LOCALES   	/usr/share/locale/
09:58:01 SCRIPT_MODULE_INIT_FILE     	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Upper/upper.sh
09:58:01 TEXTDOMAIN                  	idforge
09:58:01 TEXTDOMAINDIR               	/usr/share/locale/
09:58:01 export -f                   	upper
09:58:01 ------------------------->  	upper 
O              	
09:58:01 <-------------------------  	upper 
09:58:01 unset -f                    	upper
09:58:01 <=========================  	[3] | camel
09:58:01 <-------------------------  	camel 
09:58:01 unset -f                    	camel
09:58:01 <=========================  	[2] | output
09:58:01 <-------------------------  	output 
09:58:01 unset -f                    	output
09:58:01 <=========================  	[1] | hello
09:58:01 <-------------------------  	hello --camel hello 
09:58:01 unset -f                    	hello
09:58:01 unset -f                    	hello_getOptions
09:58:01 unset -f                    	hello_printDescription
09:58:01 <=========================  	[0] | main
----------------------------------------------------------------------
======================================================================

[[parent-modules-environment]]
=== Parent Modules

Parent modules are initiated executing the
*idforge*setModuleEnvironment_ function with the _-t "parent"_
arguments set on it. 

When the --debug option is provided to *idforge*, the parent modules
are identified by the word ``parent'' on the right side of
SCRIPT_MODULE_TYPE environment variable.

Parent modules are very simple in design and you can use them to
implement simple solutions quickly. Normally, when you execute a
parent module, you initiate the highest module environment possible
inside *idforge* script.  Parent modules are frequently used to define
module-specifc global variables, interpret module-specific options
passed through the command-line and execute the appropriate actions
based on them (e.g., executing a chain of child modules).

[[parent-module-layout]]
.idforge-hello parent module directory layout
======================================================================
----------------------------------------------------------------------
/usr/libexec/idforge/Modules
`-- Hello/
    |-- hello_getOptions.sh             <2>
    |-- hello_printDescription.sh       <3>
    `-- hello.sh                        <1>
        `-- Modules
            `-- Output
                |-- Modules
                |   |-- Camel
                |   |   `-- camel.sh
                |   |-- Lower
                |   |   `-- lower.sh
                |   |-- Random
                |   |   `-- random.sh
                |   `-- Upper
                |       `-- upper.sh
                `-- output.sh
----------------------------------------------------------------------
<1> Module initialization.
<2> Module command-line parser.
<3> Module description.
======================================================================

The module's initialization contains the module's main function
definition.  The function definition is written using the long
definition format (i.e., it must begin with the word +function+, then
the function name, and finally the +{+ character).  The name of the
function is exactly the same of the initialization file but without
the +.sh+ extension. These conditions are required in order for
*idforge* script to execute the function definition and destroy it
when it is no longer used.  See <<hello>>.

Inside the function definition you write all the commands you want the
module to run, once executed.  The function definition can be as
simple as one single line of code or as complex as you can imagine
(too complex code is sign of bad design, so keep it simple). It is the
place where you express your solutions.   

In case you notice the initialization file is growing up inevitably,
you can reduce its code by refactoring it.  To do this, you can use
resources like module-specific functions and child modules.  These
resources are described in <<module-optimization>>, and they help you
to keep the initialization file in a simple state, easy to understand,
maintain and debug.

[[hello]]
.hello.sh
======================================================================
----------------------------------------------------------------------
#!/bin/bash
######################################################################
#
#   idforge-hello - Print a greeting and exit successfully.
#   Copyright Â© 2015 CentOS Artwork SIG
#
#   idforge-hello is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License as
#   published by the Free Software Foundation; either version 2 of the
#   License, or (at your option) any later version.
#
#   idforge-hello is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with idforge-hello; if not, write to the Free Software
#   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#   Alain Reguera Delgado <alain.reguera@gmail.com>
#   39 Street No. 4426 Cienfuegos, Cuba.
#
######################################################################

# Print greeting messages and exit successfully.
function hello {

    # Initialize actions list.
    local ACTIONS=''

    # Initialize command-line interpreting both arguments and options
    # passed through it. So actions list can be redefined.
    local ARGUMENT='' ARGUMENTS=''; hello_getOptions "${@}"

    # Execute output child module to process actions for each
    # argument.
    for ARGUMENT in ${ARGUMENTS};do
        idforge_setModuleEnvironment -m 'output' -t 'child' -g "${ARGUMENT}"
    done

}
----------------------------------------------------------------------
======================================================================

When you write functions for *idforge* modules, you should add a top
comment on it, describing the legal status of your code. See the
section ``How to Apply These Terms to Your New Programs'' in the
LICENSE file.

[[module-optimization]]
Module Optimization
-------------------

*idforge* provides four resources that you can use to optimize your
module implementations. These resources are ``related functions,''
``child modules,'' ``sibling modules'' and ``recursive modules''.

[[related-functions]]
=== Related Functions

Related functions or module-specific functions are very useful for
refactoring module implementations.  Related functions must be created
thinking in executing them always, whenever the module scope they
pertain to is executed. Such an example of this usage is how parent
modules parse arguments provided in the command-line .  For example,
the initialization script <<hello>> uses the <<hello_getOptions>>
related function to interpret the arguments passed through the
command-line.  Notice how many lines in the initialization script has
been reduced.

Related functions are written using the module's name, then an
underscore (+\_+), then a descriptive name and, finally, the +.sh+
extension. The function definition inside the function file also
follows such convention but excludes the +.sh+ extension from name
(e.g., the function file +hello_getOptions.sh+ has a function
definition named +hello_getOptions+ inside).  These conventions are
used to export and destroy the related functions when new module
environments are created and destroyed.  If you create related
function files with a pattern different from that described here, they
will not be executed nor available inside the initialization file of
the module environment being currently executed.

[[hello_getOptions]]
.hello_getOptions.sh (legal status cut for brevity)
======================================================================
----------------------------------------------------------------------
# Interpret module-specific options for hello.
function hello_getOptions {

    # Define short options we want to support.
    local ARGSS="h,v,s,g:,l,u,c,r"

    # Define long options we want to support.
    local ARGSL="help,version,description,lower,upper,camel,random"

    # Redefine arguments using getopt(1) command parser and reset
    # positional parameters on this function, using output produced
    # from (getopt) arguments parser.
    ARGUMENTS=''; idforge_setArguments "${@}"; eval set -- "${ARGUMENTS}"

    # Look for options passed through command-line.
    while true; do
        case "${1}" in

            -h | --help )
                idforge_printHelp
                ;;

            -v | --version )
                idforge_printVersion
                ;;

            -s | --description )
                hello_printDescription
                shift 1
                ;;

            -l | --lower )
                ACTIONS="lower ${ACTIONS}"
                shift 1
                ;;

            -u | --upper )
                ACTIONS="upper ${ACTIONS}"
                shift 1
                ;;

            -c | --camel )
                ACTIONS="camel ${ACTIONS}"
                shift 1
                ;;

            -r | --random )
                ACTIONS="random ${ACTIONS}"
                shift 1
                ;;

            -- )
                shift 1
                break
                ;;
        esac
    done

    # Redefine arguments using current positional parameters. Only
    # paths should remain as arguments at this point.
    ARGUMENTS="${@}"

}
----------------------------------------------------------------------
======================================================================

[NOTE]
======================================================================
<<hello_getOptions>> related function presents the construction
standard we use inside *idforge* for parsing arguments passed through
the command-line in a per-module basis.  As convention, all the parent
modules definitions you write must be able to interpret the *--help*
and *--version* options using the construction described here.
======================================================================

Related functions aren't very efficient when you need to execute them
at demand (e.g., based on specific conditions). When a module is
executed, related functions are exported to *idforge* shell
environment. They remain there, consuming memory, until the module
they belong to is destroyed. If you create a related function and
never execute it, it will consume memory, as well. So, use related
functions when you are absolutely sure they will be executed at some
point, in one single iteration of *idforge*.  If you need to execute
functions at demand, use child modules, instead.

[[child-modules]]
=== Child Modules

Child modules are initiated by executing the
*idforge*setModuleEnvironment_ function with the _-t "child"_
arguments set on it. 

When the --debug option is provided to *idforge*, the parent modules
are identified by the word ``child'' on the right side of
SCRIPT_MODULE_TYPE environment variable.

Child modules have the characteristic of being nested modules.  They
cannot be executed from the command-line. Normally, child modules are
executed from parent modules but they can be executed from other child
modules, as well.

When several child modules are executed in one single iteration of
*idforge*, they create a chain of modules.  Chain of modules are
generally created when you want to divide one large task into smaller
tasks and also control which of these smaller tasks is executed based
on specific conditions (e.g., you may want to render images or
documentation, but not both, in one single iteration of *idforge*
script).  

In a chain of modules, lower modules in the chain (those started last)
have access to information set by modules higher in the chain (those
started first), but not in the opposite order. When processing
information this way, modules aren't destroyed until the last module
executed in the chain has finished its work (e.g., all the commands
inside it have been executed). At that point, child modules are
destroyed automatically in the reverse order they were executed.

<<module-environments-in-action>> shows the child modules' ability of
reducing scope as they get deeper in the chain of executed modules.
However, child modules lack the possibility of nesting modules that
share the same scope. For instance, <<module-environments-in-action>>,
you cannot execute the modules _lower_  or _upper_ from _camel_
module, as if they were child modules of _camel_ module.  That is not
possible because they all have the same scope, which is, to print the
greeting message to standard output. 

Child modules are conceived to reduce the module scope as new child
modules are executed. When you need to execute new module environments
and, also, retain the previous scope from which the new module was
executed, you need to use ``sibling modules,'' instead.

[[sibling-modules]]
=== Sibling Modules

Sibling modules are initiated
by executing the *idforge*setModuleEnvironment_ function with the _-t
"sibling"_ arguments set on it. 

When the --debug option is provided to *idforge*, the parent modules
are identified by the word ``sibling'' on the right side of
SCRIPT_MODULE_TYPE environment variable.

Sibling modules are another type of nested modules but, in contrast to
child modules, sibling modules cannot be executed from parent modules.
Normally, sibling modules are executed from other sibling modules but,
considering the context, they can be executed from child modules too,
to initiate sibling processing. 

When several siblings modules are executed, they also build a chain of
modules. In contrast to chain of child modules, the chain of sibling
modules destroys the last sibling module executed before executing the
next sibling module. This makes the chain to stop its growing at
sibling module processing, unless you call a child module from a
sibling module. In which case, the chain expansion would continue
growing as long as the number of child modules you execute. This
process becomes more visible when you take a look at
<<module-environments-in-action>>.

Normally, one module is executed at some point and destroyed at the
same point when it has finished its work, however, what if the next
immediate module you are about to execute is the same module you are
about to destroy? This is, you need to execute the last module in the
chain of executed modules again, but, this time, from itself.  In
cases like this, the *idforge* script doesn't destroy the last module.
It cannot, because you are certainly executing a new module from
itself, so it has to wait for this new call to finish in order to be
destroyed. This kind of processing is known as ``processing modules
recursively.''_

[[recursive-modules]]
=== Recursive Modules

When one module environment executes itself we are in presence of a
recursive module execution. The recursive execution of modules doesn't
destroy the last module in the chain of executed modules and doesn't
increment or decrement the module counter either. The module counter
is somehow frozen until a different module environment is executed. In
these cases, the last module environment remains in memory for the new
module execution so it can be reused. This process becomes more
visible when you take a look at <<debug-recursive-modules>>.

[CAUTION]
======================================================================
When you execute modules recursively, you should be very careful not
to get trapped into an endless loop.
======================================================================

[[debug-recursive-modules]]
.Processing execution of modules recursively
======================================================================
----------------------------------------------------------------------
08:57:22 =========================>  	[0] | main
08:57:22 SCRIPT_MODULE_BASEDIR       	/usr/libexec/idforge/Modules
08:57:22 SCRIPT_MODULE_NAME          	[0]=hello
08:57:22 SCRIPT_MODULE_TYPE          	parent
08:57:22 SCRIPT_MODULE_ARGUMENT      	--random hello 
08:57:22 SCRIPT_MODULE_LIST          	hello|locale|pack|prepare|render|tuneup
08:57:22 SCRIPT_MODULE_DIR           	/usr/libexec/idforge/Modules/Hello
08:57:22 SCRIPT_MODULE_DIR_MODULES   	/usr/libexec/idforge/Modules/Hello/Modules
08:57:22 SCRIPT_MODULE_DIR_CONFIGS   	/usr/libexec/idforge/Modules/Hello/Configs
08:57:22 SCRIPT_MODULE_DIR_MANUALS   	/usr/libexec/idforge/Modules/Hello/Manuals
08:57:22 SCRIPT_MODULE_DIR_LOCALES   	/usr/share/locale/
08:57:22 SCRIPT_MODULE_INIT_FILE     	/usr/libexec/idforge/Modules/Hello/hello.sh
08:57:22 TEXTDOMAIN                  	idforge
08:57:22 TEXTDOMAINDIR               	/usr/share/locale/
08:57:22 export -f                   	hello
08:57:22 export -f                   	hello_getOptions
08:57:22 export -f                   	hello_printDescription
08:57:22 ------------------------->  	hello --random hello 
08:57:22 =========================>  	[1] | hello
08:57:22 SCRIPT_MODULE_BASEDIR       	/usr/libexec/idforge/Modules/Hello/Modules
08:57:22 SCRIPT_MODULE_NAME          	[1]=output
08:57:22 SCRIPT_MODULE_TYPE          	child
08:57:22 SCRIPT_MODULE_ARGUMENT      	hello 
08:57:22 SCRIPT_MODULE_LIST          	output
08:57:22 SCRIPT_MODULE_DIR           	/usr/libexec/idforge/Modules/Hello/Modules/Output
08:57:22 SCRIPT_MODULE_DIR_MODULES   	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules
08:57:22 SCRIPT_MODULE_DIR_CONFIGS   	/usr/libexec/idforge/Modules/Hello/Modules/Output/Configs
08:57:22 SCRIPT_MODULE_DIR_MANUALS   	/usr/libexec/idforge/Modules/Hello/Manuals
08:57:22 SCRIPT_MODULE_DIR_LOCALES   	/usr/share/locale/
08:57:22 SCRIPT_MODULE_INIT_FILE     	/usr/libexec/idforge/Modules/Hello/Modules/Output/output.sh
08:57:22 TEXTDOMAIN                  	idforge
08:57:22 TEXTDOMAINDIR               	/usr/share/locale/
08:57:22 export -f                   	output
08:57:22 ------------------------->  	output hello 
08:57:22 =========================>  	[2] | output
08:57:22 SCRIPT_MODULE_BASEDIR       	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules
08:57:22 SCRIPT_MODULE_NAME          	[2]=random
08:57:22 SCRIPT_MODULE_TYPE          	child
08:57:22 SCRIPT_MODULE_ARGUMENT      	
08:57:22 SCRIPT_MODULE_LIST          	camel|lower|random|upper
08:57:22 SCRIPT_MODULE_DIR           	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Random
08:57:22 SCRIPT_MODULE_DIR_MODULES   	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Random/Modules
08:57:22 SCRIPT_MODULE_DIR_CONFIGS   	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Random/Configs
08:57:22 SCRIPT_MODULE_DIR_MANUALS   	/usr/libexec/idforge/Modules/Hello/Manuals
08:57:22 SCRIPT_MODULE_DIR_LOCALES   	/usr/share/locale/
08:57:22 SCRIPT_MODULE_INIT_FILE     	/usr/libexec/idforge/Modules/Hello/Modules/Output/Modules/Random/random.sh
08:57:22 TEXTDOMAIN                  	idforge
08:57:22 TEXTDOMAINDIR               	/usr/share/locale/
08:57:22 export -f                   	random
08:57:22 ------------------------->  	random 
l              	
08:57:22 ~~~~~~~~~~~~~~~~~~~~~~~~~>  	random 
e              	
08:57:22 ~~~~~~~~~~~~~~~~~~~~~~~~~>  	random 
o              	
08:57:22 ~~~~~~~~~~~~~~~~~~~~~~~~~>  	random 
l              	
08:57:22 ~~~~~~~~~~~~~~~~~~~~~~~~~>  	random 
o              	
08:57:22 <-------------------------  	random 
08:57:22 unset -f                    	random
08:57:22 <=========================  	[2] | output
08:57:22 <-------------------------  	output hello 
08:57:22 unset -f                    	output
08:57:22 <=========================  	[1] | hello
08:57:22 <-------------------------  	hello --random hello 
08:57:22 unset -f                    	hello
08:57:22 unset -f                    	hello_getOptions
08:57:22 unset -f                    	hello_printDescription
08:57:22 <=========================  	[0] | main
----------------------------------------------------------------------
======================================================================

Recursive execution of modules occurs only when the module you are
executing is considered sibling of the last module executed in the
chain of executed modules and they both have the same name. The fact
that no variable name is printed out in <<debug-recursive-modules>>
means that they were not created. The arrows' style changes from +->+
to +~>+ meaning that module-specific functions weren't exported for
the new module execution either. It also means that the initialization
script is reusing both related functions and variables from the last
module environment in the chain of executed modules. In this case the
_random_ module.

[[module-structure]]
Module Structure
----------------

+<module_name>.sh+::
    Initialization file.

+<module_name>_getOptions.sh+::
    Command-line parser.

+Modules/+::
    This directory contains nested modules (e.g., child modules) and
    is used for extending the current module functionality in a
    modular way.  There isn't a visible limitation in the number of
    Modules directories you can nest inside one module to achieve
    certain functionality so, you can create as many levels of Modules
    directories as you need.

+Locales/+::
    This directory contains localization files for all shell scripts
    in the module. The content of this directory is managed using
    _idforge-locale(1)_ command.

+Manuals/+::
    This directory contains module-specific documentation manuals in
    asciidoc format as well as a Locales/ sub-directory to manage
    localization of documentation manuals.

+Configs/+::
    This directory contains module-specific configuration files.

== Author

include::Commons/author.inc[]

== Copyright

include::Commons/copyright.inc[]

== See also

=MANPAGE_OTHERS=

// vim: set syntax=asciidoc:
